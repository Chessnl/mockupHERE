package COMSETsystem;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashSet;
import java.util.PriorityQueue;


/**
 * 
 * @author Robert van Barlingen and Jeroen Schols
 * mail Bobby.van.BarlingenWgmail.com
 * 
 * The CityMap represents the map of a city. It can also include a grid 
 * used to quickly find the closest intersection for each point in a square area
 * around the map.
 * The map is represented as a directed graph of intersections connected by roads. 
 * (See Intersection and Road class for more details).
 * 
 * This city implements all the functionality related to using the map.
 * This functionality includes:
 * ...
 * ...
 * 
 * The map is generated by reading the JSON map (and grid) file(s) generated by 
 * MapCreator. The grid in this case is optional.
 * 
 * The map is stored as a mapping (HashMap) from the id of every intersection
 * to the intersection itself. These intersections in turn store outgoing roads,
 * thereby creating a graph. 
 * The grid is stored as a list of lists of intersection ids. This defined a matrix
 * in which each element represents a small square area which is mapped to the 
 * nearest intersection. Therefore, a point in a square can quickly be mapped to 
 * the nearest intersection.
 */
public class CityMap implements Iterable<Intersection>, Serializable {
    private static final long serialVersionUID = -8020298097735108102L;
    
    // a mapping from all the intersection ids to corresponding Interesctions
    private Map<Long, Intersection> intersections;
    private long numberIntersections; //number of intersections
    // maximum and minimum longitude and latitude
    private double maxLat;
    private double minLat;
    private double maxLong;
    private double minLong;
    
    private HashMap<Long, HashMap<Long ,Long>> distances = new HashMap<>();
    
    
    // a square grid of squares.The intesection in each square means that the intersection
    // is inside the square or the intersection is the closest intersection out of all 
    // the intersections.
    // The square grid is defined by the bottom left corner (x and y coordinate, 
    // i.e. longitude and latitude), by the length of the sides, the number of divisions into smaller
    // squares and the length of the sides of the smaller squares.
    // Note 1: this length of sides of smaller squares is superfluous since it can be
    // computer from the other information.
    // Note 2: the grid refers to the id of the interesctions, not the intersections
    // themselves
    private List<List<Long>> grid;
    private double gridSideLength; // length of the sides of the grid
    private double squaresSideLength; // length of the sides of the smaller squares
    // number of divisions of the grid into small squares
    // Note that this indicates the number of divisions along the length and along the width
    // of the grid. Therefore the total number of squares is numberDivisions^2.
    private long numberDivisions; // number of divisions of the grid into small squares
    private double bottomLeftX; // x-coordinate of bottom left corner of grid
    private double bottomLeftY; // y-coordinate of bottom left corner of grid
    
    /**
     * Constructor used to create the map based on JSON files generated by
     * the MapCreator class.
     * 
     * @param filename the filename of the map to be read.
     *                  e.g. SanFrancisco
     *                      NOT SanFrancisco.json or SanFrancisco_map
     */
    public CityMap(String filename) {
        readMap(filename);
        readGrid(filename);
    } 
    
    public CityMap(Map<Long, Intersection> intersections, long numberIntersections, 
            double maxLat, double minLat, double maxLong, double minLong,
            List<List<Long>> grid, double gridSideLength, double squaresSideLength,
            long numberDivisions, double bottomLeftX, double bottomLeftY) {
        this.intersections = intersections;
        this.numberIntersections = numberIntersections;
        this.maxLat = maxLat;
        this.minLat = minLat;
        this.maxLong = maxLong;
        this.minLong = minLong;
        this.grid = grid;
        this.gridSideLength = gridSideLength;
        this.squaresSideLength = squaresSideLength;
        this.numberDivisions = numberDivisions;
        this.bottomLeftX = bottomLeftX;
        this.bottomLeftY = bottomLeftY;
    }
    
    // TODO: add javaadoc
    public long timeBetween (Intersection start, Intersection stop) {
		return distances.get(start).get(stop);
	}
    
    /**
     * Creates a map based on the JSON map file generated by the MapCreator class.
     * The filename that is given as input should only contain the name of the
     * original OpenStreetMaps JSON file, without extention.
     * e.g. SanFrancisco, NOT SanFrancisco.json or SanFrancisco_map
     * 
     * @param filename The filename of the map to be read.
     */
    private void readMap(String filename) {
        JSONParser parser = new JSONParser();
        // if the grid file is not found then it is simply not defined and the 
        // algoirthm continues without throwing an exception
        try {
            intersections = new HashMap<>(); //initialize the map
            Reader reader = new FileReader("maps/" + filename + "_map.json"); // read map file
            Object obj = parser.parse(reader); //parse the json file
            JSONObject map = (JSONObject) obj; //the json file as an objsct
            numberIntersections = (long) map.get("numberIntersections"); // set the number of intersections
            maxLat = (double) map.get("maximumLatitude");
            minLat = (double) map.get("minimumLatitude");
            maxLong = (double) map.get("maximumLongitude");
            minLong = (double) map.get("minimumLongitude");
            JSONArray intersectionsJSON = (JSONArray) map.get("intersections");
            // loop over all the intersections and set them accordingly
            for (Object intersectionObject : intersectionsJSON) {
                JSONObject intersectionJSON = (JSONObject) intersectionObject;
                double longitude = (double)intersectionJSON.get("longitude");
                double latitude = (double)intersectionJSON.get("latitude");
                long id = (long) intersectionJSON.get("id");
                Intersection inter = new Intersection(longitude, latitude, id);
                intersections.put(id, inter);
            }
            
            // loop over all the intersections again in order to set the roads
            for (Object intersectionObject : intersectionsJSON) {
                JSONObject intersectionJSON = (JSONObject) intersectionObject;
                JSONArray roadsJSON = (JSONArray)intersectionJSON.get("roads");
                long intersectionID = (long) intersectionJSON.get("id"); // id of the current intersection
                for (Object roadObject : roadsJSON){
                    JSONObject roadJSON = (JSONObject) roadObject;
                    double distance = (double)roadJSON.get("distance");
                    long speed = (long) roadJSON.get("speed");
                    long id = (long) roadJSON.get("to"); // id of the intersection that the road goes to
                    // adds road to intersection
                    intersections.get(intersectionID).addEdge(intersections.get(id), distance, speed); 
                }
            }
        } catch (FileNotFoundException e) {
            System.out.println(filename + "_map.json not found.");
        } catch (IOException e) {
            System.out.println(e);
        } catch (ParseException e) {
            System.out.println(e);
        }
    }
    
    /**
     * Creates the grid based on the JSON grid file generated by the MapCreator class.
     * The filename that is given as input should only contain the name of the
     * original OpenStreetMaps JSON file, without extention.
     * e.g. SanFrancisco, NOT SanFrancisco.json or SanFrancisco_grid
     * 
     * Note that the grid is optional. However if the map is not set, then it
     * is not possible to find the nearest intersection to a certain point.
     * 
     * @param filename The filename of the map to be read.
     */
    private void readGrid(String filename) {
        JSONParser parser = new JSONParser();
        try {
            Reader reader = new FileReader("maps/" + filename + "_grid.json"); // read map file
            Object obj = parser.parse(reader); //parse the json file
            JSONObject gridJSON = (JSONObject) obj; //the json file as an objsct
            bottomLeftX = (double)gridJSON.get("bottomLeftX");
            bottomLeftY = (double)gridJSON.get("bottomLeftY");
            numberDivisions = (long)gridJSON.get("numberDivisions");
            gridSideLength = (double)gridJSON.get("gridLength");
            squaresSideLength = gridSideLength/(double)numberDivisions;
            JSONArray columnsJSON = (JSONArray) gridJSON.get("grid");
            grid = new ArrayList<List<Long>>((int)numberDivisions);
            for (Object columnObject : columnsJSON) {
                JSONArray elementsJSON = (JSONArray) columnObject;
                List<Long> column = new ArrayList<Long>((int)numberDivisions);
                for (Object idObject : elementsJSON) {
                    long id = (long)idObject;
                    column.add(id);
                }
                grid.add(column);
            }
        } catch (FileNotFoundException e) {
            System.out.println(filename + "_grid.json not found.");
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Returns whether or not the grid has been set.
     * 
     * @return a boolean value indicating if the grid has been set
     */
    public boolean hasGrid() {
        return (grid != null);
    }
    
    /**
     * Check is the grid has been implemented. If not, then it throws a 
     * FileNotFoundException. 
     * @throws FileNotFoundException if { @code !hasGrid() }
     */
    private void checkGrid() throws FileNotFoundException {
        if ( !hasGrid() ) {
            throw new FileNotFoundException("The city map does not contain a grid");
        }
    }
    
    /**
     * @return { @code maxLat } 
     */
    public double maxLatitude() {
        return maxLat;
    }
    
    /**
     * @return { @code minLat } 
     */
    public double minLatitude() {
        return minLat;
    }
    
    /**
     * @return { @code maxLong } 
     */
    public double maxLongitude() {
        return maxLong;
    } 
    
    /**
     * @return { @code minLong } 
     */
    public double minLongitude() {
        return minLong;
    }
    
    /**
     * @return { @code bottomLeftX } 
     */
    public double bottomLeftX() {
        return bottomLeftX;
    }
    
    /**
     * @return { @code bottomLeftY } 
     */
    public double bottomLeftY() {
        return bottomLeftY;
    }
    
    /**
     * @return { @code numberDivisions } 
     */
    public double numberDivisions() {
        return numberDivisions;
    }
    
    /**
     * @return { @code squaresSideLength() } 
     */
    public double squaresSideLength() {
        return squaresSideLength;
    }
    
    /**
     * @return { @code gridSideLength } 
     */
    public double gridSideLength() {
        return gridSideLength;
    }
    
    /**
     * checks whether a point defined by { @code longitude, latitude } is inside the grid.
     * 
     * 
     * @param longitude The longitude of the point
     * @param latitude The latitude of the point
     * @return whether the point defined by { @code longitude, latitude }
     * is inside the area defined by the grid.
     * @throws FileNotFoundException if { @code !hasGrid() }
     */
    public boolean inGrid(double longitude, double latitude) throws FileNotFoundException {
        checkGrid();
        return ( bottomLeftX <= longitude 
                && bottomLeftY <= latitude
                && longitude <= bottomLeftX + gridSideLength
                && latitude <= bottomLeftY + gridSideLength);
    }
    
    /**
     * Uses the grid to find the nearest intersection of a point defined by the 
     * { @code longitude, latitude }.
     * The intersection is returned as an id.
     * If the grid isn't created yet when this method is called, it is created first
     * 
     * @param longitude The longitude of the point
     * @param latitude The latitude of the point
     * @return The closest intersection to a specific point
     * @throws java.io.FileNotFoundException if the the map doesn't have a grid
     */
    public Intersection getNearestIntersection(double longitude, double latitude) 
            throws FileNotFoundException, IllegalArgumentException {
        // check if the point is inside the grid to begin with
        if ( !inGrid( longitude, latitude ) ) {
            throw new IllegalArgumentException("Point (" + longitude + ", " + latitude + 
                    ") is not inside the grid defined by bottom left point (" +
                    bottomLeftX + ", " + bottomLeftY + ") and gridSideLegth = " + 
                    gridSideLength);
        }
        // find the correct square based on the coordinates of the point
        // TODO: find something more efficient to get rid of boundy case if x or y = numDivisions
        //      than taking the minimum for all
        int x = Math.min((int)((longitude - bottomLeftX)/squaresSideLength), (int) numberDivisions - 1);
        int y = Math.min((int)((latitude - bottomLeftY)/squaresSideLength), (int) numberDivisions - 1);
        return getIntersection(grid.get(x).get(y));
    }
    
    /**
     * Get the intersection defined by { @code id }
     * 
     * @param id The id of the intersection that is fetched
     * @return The intersection defined by { @code id }
     */
    public Intersection getIntersection (Long id) {
        return intersections.get(id);
    }
    
    /**
     * Returns a set with the ids of all the intersections in the cityMap/
     * 
     * @return A set of all the ids 
     */
    public Set<Long> getIdSet() {
        return intersections.keySet();
    }
    
    /**
     * Creates and returns an iterator for iterating over all the intersections
     * in the map.
     * 
     * @return An iterator for iterating over the intersections
     */
    @Override 
    public Iterator<Intersection> iterator() {
        return new CityMapIterator();
    }
    
    /**
     * An iterator class which enables iterating over all the intersections in 
     * the map.
     */
    public class CityMapIterator implements Iterator<Intersection> {
        Iterator<Long> idIterator;
        public CityMapIterator() {
            idIterator = intersections.keySet().iterator();
        }
        
        @Override
        public boolean hasNext() {
            return idIterator.hasNext();
        }
        
        @Override
        public Intersection next() {
            return intersections.get(idIterator.next());
        }
        
        @Override
        public void remove() throws UnsupportedOperationException {
            throw new UnsupportedOperationException("CityMapIterator.remove() "
                    + "is not supported.");
        }
        
    }
    
    /**
     * Makes the map final and unmodifiable
     */
    public void fixStructure () {
        for (Long id : intersections.keySet()) {
                intersections.get(id).fixStructure();
        }
        calcDistances();
        intersections = Collections.unmodifiableMap(intersections);
        grid = Collections.unmodifiableList(grid);
    }

    private void calcDistances() {
        for (Long from : intersections.keySet()) {
            HashMap<Long, DijkstraQueueEntry> queueEntry = new HashMap<>();
            PriorityQueue<DijkstraQueueEntry> queue = new PriorityQueue<>();
            for (Long i : intersections.keySet()) {
                    queueEntry.put(i, new DijkstraQueueEntry(i));
                    queue.add(queueEntry.get(i));
            }
            DijkstraQueueEntry fromEntry = queueEntry.get(from);
            queue.remove(fromEntry);
            fromEntry.cost = 0;
            queue.add(fromEntry);

            while (!queue.isEmpty()) {
                    DijkstraQueueEntry entry = queue.poll();
                    entry.inQueue = false;

                    for (Road r : intersections.get(entry.id).getRoadsFrom()) {
                            DijkstraQueueEntry v = queueEntry.get(r.to.id);
                            if (!v.inQueue)
                                    continue;
                            long ncost = entry.cost + r.time;
                            if (v.cost > ncost) {
                                    queue.remove(v);
                                    v.cost = ncost;
                                    queue.add(v);
                            }
                    }
            }

            HashMap<Long, Long> fromDistances = new HashMap<>();
            for (DijkstraQueueEntry entry : queueEntry.values()) {
                    fromDistances.put(entry.id, entry.cost);
            }
            distances.put(from, fromDistances);
        }
    }

	private class DijkstraQueueEntry implements Comparable<DijkstraQueueEntry> {
		Long id;
		long cost = Long.MAX_VALUE;
		boolean inQueue = true;

		DijkstraQueueEntry(Long id) {
			this.id = id;
		}

		@Override
		public int compareTo(DijkstraQueueEntry j) {
			if (this.cost < j.cost) {
				return -1;
			} else if (this.cost > j.cost) {
				return 1;
			} else {
				return 0;
			}
		}

	}
}