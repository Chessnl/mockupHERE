package MapCreation;

import COMSETsystem.*;
import java.io.FileNotFoundException;
import java.util.NoSuchElementException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Map;
import java.util.HashMap;
import java.util.Objects;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.kynosarges.tektosyne.geometry.*;
import org.kynosarges.tektosyne.subdivision.*;


/**
 * @author Robert van Barlingen
 * mail Bobby.van.Barlingen@gmail.com
 * 
 *  Reads the a JSON file generated by OpenStreetMaps and creates a directed map based on this file.
 *  The created map is saved as a list of Intersections. In the map generated from the 
 *  OpenStreetMaps data, these intersections can represent many things, from a traffic
 *  sign to a road bump to a street corner. Intersections also contain roads connecting
 *  an intersection to other intersections. (See class Intersection for more details).
 * 
 *  Once a JSON file is read and converted to map, the constructor provides the ability
 *  to clean the map. Cleaning the map implies that it removes all unnecessary data such
 *  as traffic signs, speed bumps, etc. The only thing that remains are street corners 
 *  connecting multiple streets.
 *  This reduces the number of intersections roughly by a factor of 10.
 * 
 *  The MapCreator also provides the ability to group intersections. This implies that all the
 *  intersections which lie within a certain distance of each other are converted to a single intersections.
 *  This reduces the number of intersections roughly by a factor of 2.
 * 
 *  MapCreator can also generate a voronoi diagram based on the the map. This diagram 
 *  maps every point in a square area around the map to the closest intersection.
 *  This is done by dividing the area in small squares such that there is at most 1
 *  intersection in each square. Each square is then mapped to the closest intersection.
 *  the grid consisting of a matrix of all these squares is saved in a list of lists.
 *  Using this grid mapping a point in the square area to the closest corner can be
 *  done in constant time.
 *  the number of squares depends on the minimum distance between any two intersections.
 *  Therefore, in order to reduce the number of squares it is highly advised to first 
 *  group the nodes.
 * 
 *  Once the map (and grid) are generated, they can be output to (a) json file(s).
 *  These files can then be read by the CityMap class.
 */
public class MapCreator {
    
    // the filename of the OpenStreetMaps file to read. Will also be used 
    // to output the map and grid.
    // All files are assumed to be located in directory /maps/ 
    // e.g. SanFrancisco
    // don't add .json to the file name. This is done by the class itself.
    String filename;
    
    // set of speed limits associated with each OpenStreetMaps road type.
    final static int speedMotorway = 120;
    final static int speedMotorwayLink = speedMotorway;
    final static int speedTrunk = 100;
    final static int speedTrunkLink = speedTrunk;
    final static int speedPrimary = 100;
    final static int speedPrimaryLink = speedPrimary;
    final static int speedSecondary = 80;
    final static int speedSecondaryLink = speedSecondary;
    final static int speedTertiary = 50;
    final static int speedTertiaryLink = speedTertiary;
    final static int speedUnclassified = 50;
    final static int speedResidential = 50;
    final static int speedLivingStreet = 30;
    final static int speedDefault = 50;
    
    //distance used to group nodes together if they're too close 
    final double minimumDistance = 0.0005; 
    
    // map from id's to intersections. This represents the map
    Map<Long, Intersection> intersections;
    
    // used to set id's of newly added nodes, such that they're always unique.
    long idCounter;
    
    // the grid used to map any location to the closest intersection.
    // the area of the grid is defined by the x- and y-coordinates (longitude
    // and latitude) of bottom left corner of the grid, the width of the square
    // and the width of the smaller squares.
    // Note that the grid refers to intersections by their id.
    List<List<Long>> grid;
    double bottomLeftX;
    double bottomLeftY;
    double gridLength;
    double squareLength;
    
    /**
     * constructor of the mapReader. Reads the JSON file defined by fileName and
     * converts it into a map represented by { @code intersections ).
     * Uses Json.simple package
     * 
     * @param fileName the JSON file that will be read
     * modifies {@code intersections } 
     * modifies {@code filename }
     * 
     */
    public MapCreator(String fileName) {
        filename = fileName; // sets the filename
        intersections = new HashMap<>(); // initialize intersections
        JSONParser parser = new JSONParser();
        try {
            // read file
            Reader reader = new FileReader("maps/" + filename + ".json");
            // create JSONObject based on the file
            Object obj = parser.parse(reader);
            JSONObject jsonObject = (JSONObject) obj;

            // loop over all the elements in the JSON file to set all the interesctions
            JSONArray elements = (JSONArray) jsonObject.get("elements");
            for (Object elementObject : elements) {
                JSONObject element = (JSONObject) elementObject;
                String type = (String) element.get("type");
                // if the type is a node, then create an Intersection
                if (type.equals("node")) {
                    long id = (long) element.get("id");
                    double latitude = (double) element.get("lat");
                    double longtitude = (double) element.get("lon");
                    intersections.put(id, new Intersection(longtitude, latitude, id));
                }
            }
            
            // loop over all the elements again to set the roads
            for (Object elementObject : elements) {
                JSONObject element = (JSONObject) elementObject;
                String type = (String) element.get("type");
                if (type.equals("way")) { // check if it's a road
                    String highway;
                    int maxSpeed;
                    boolean oneway = false;
                    Object tagsObject = element.get("tags");
                    JSONObject tags = (JSONObject) tagsObject;
                    highway = (String)tags.get("highway");
                    // set speed limit
                    if (tags.containsKey("maxspeed")) {
                        String speedString = (String) tags.get("maxspeed");
                        if( speedString.contains(" mph")) {
                            speedString = speedString.replace(" mph", "");
                        }
                        maxSpeed = Integer.parseInt(speedString);
                    } else {
                        switch(highway) {
                            case "motorway": 
                                maxSpeed = speedMotorway;
                                break;
                            case "motorway_link":
                                maxSpeed = speedMotorwayLink;
                                break;
                            case "trunk":
                                maxSpeed = speedTrunk;
                                break;
                            case "trunk_link":
                                maxSpeed = speedTrunkLink;
                                break;
                            case "primary":
                                maxSpeed = speedPrimary;
                                break;
                            case "primary_link":
                                maxSpeed = speedPrimaryLink;
                                break;
                            case "secondary":
                                maxSpeed = speedSecondary;
                                break;
                            case "secondary_link":
                                maxSpeed = speedSecondaryLink;
                                break;
                            case "tertiary":
                                maxSpeed = speedTertiary;
                                break;
                            case "tertiary_link": 
                                maxSpeed = speedTertiaryLink;
                                break;
                            case "unclassified":
                                maxSpeed = speedUnclassified;
                                break;
                            case "residential":
                                maxSpeed = speedResidential;
                                break;
                            case "living_street":
                                maxSpeed = speedLivingStreet;
                                break;
                            default:
                                maxSpeed = speedDefault;
                                break;
                        }
                    }
                    // check if it's a one way street 
                    if(tags.containsKey("oneway") && ((String)tags.get("oneway")).equals("yes")) {
                        oneway = true;
                    }
                    // set roads
                    JSONArray nodes = (JSONArray) element.get("nodes");
                    int length = nodes.size();
                    for (int i = 0; i < length - 1; i++) {
                        long id1 = (long)nodes.get(i);
                        long id2 = (long)nodes.get(i+1);
                        double distance = distance(intersections.get(id1), intersections.get(id2));
                        intersections.get(id1).addEdge(intersections.get(id2), distance, maxSpeed);
                        if (!oneway) {
                            intersections.get(id2).addEdge(intersections.get(id1), distance, maxSpeed);
                        }
                    }
                } 
            } 
            setIdCounter();
        // handle exceptions
        } catch (FileNotFoundException e) {
            System.out.println("error FileNotFoundException");
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("error IOException");
            e.printStackTrace();
        } catch (ParseException e) {
            System.out.println("error ParseException");
            e.printStackTrace();
        }
    }
    
    /**
     * Computes the distance between two intersections.
     * 
     * @param inter1 the first intersection
     * @param inter2 the second intersection
     * @return {@code sqrt((inter1.longitude - inter2.longitude)^2 + (inter1.latitude - inter2.latitude)^2) }
     */
    private double distance(Intersection inter1, Intersection inter2) {
        double x1 = inter1.longitude;
        double x2 = inter2.longitude;
        double y1 = inter1.latitude;
        double y2 = inter2.latitude;
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }
    
    /**
     * Computes the distance between two points based on coordinates
     * 
     * @param x1 the x-coordinate of the first point
     * @param y1 the y-coordinate of the first point
     * @param x2 the x-coordinate of the second point
     * @param y2 the y-coordinate of the second coordinate
     * @return {@code sqrt((x1 - x2)^2 + (y1 - y2) * (y1 - y2))}
     */
    private double distance(double x1, double y1, double x2, double y2) {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }
    
    /**
     * One iteration of the ClearMap function. Goes over every intersection
     * and determines if it's a dead end, an intersection which cannot be returned
     * from or an intersection combining two segments of the same street (i.e. an
     * intersection in the middle of a street).
     * If that's the case then this intersection is cut (removed and the intersections
     * connected to the removed intersection reconnected).
     * In order to fully clear the whole map multiple iterations of this algorithm 
     * are needed because it is possible that after removing certain intersections
     * in the first iteration, previous dead-end streets are now defined by other 
     * intersections. these intersections then have to be removed in the second 
     * iteration. 
     * 
     * modifies {@code intersections }
     */
    public void clearMapIteration() throws IllegalStateException{
        // set of intersections (ids) that need to be removed
        Set<Long> toRemove = new HashSet<>(); 
        // go over every intersection
        for (long id : intersections.keySet()) {
            Intersection inter = intersections.get(id);
            Set<Road> roadsFrom = inter.getRoadsFrom();
            Set<Road> roadsTo = inter.getRoadsTo();
            // if there is at most one road going from a certain intersection and there
            // is at most one road going to that intersection then that 
            // interescection defines a dead-end, an intersection which you
            // can't return from or an intersection in the middle of the street
            // therefore this intersection can be removed.
            if (roadsFrom.size() <= 1 && roadsTo.size() <= 1) {
                toRemove.add(id);
                continue;
            }
            
            // if there are two incoming and two outgoing roads for an interesction
            // then it's possible that that intersection lies in the middle of 
            // a two way street. Therefore this has to be checked, and if this is 
            // the case it has to be removed.
            if (roadsFrom.size() == 2 && roadsTo.size() == 2) {
                boolean checkForAll = true;
                for (Intersection interTo: inter.getAdjacentTo()) {
                    boolean check = false;
                    for (Intersection interFrom : inter.getAdjacentFrom()) {
                        if (interTo.equals(interFrom)) {
                            check = true;
                        }
                    }
                    if (!check) {
                        checkForAll = false;
                    }
                }
                if (checkForAll) {
                    toRemove.add(id);
                    continue;
                }
            }
        }
        // remove all the interesections that have to be removed
        for (Long id : toRemove) {
            // TODO: Remove these lines!!!!!!!!!!!!!!!!1
            /*int j = -1;
            for (int i = 0; i < intersections.size(); i++) {
                if (intersections.get(i).equals(inter)) {
                    j = i;
                    break;
                    
                }
            }
            
            if (j == -1) {
                throw new IllegalStateException("Sommething went horribly wrong.");
            } */
            intersections.get(id).cutNode();
            intersections.remove(id);
            
        }
    }
    
    /**
     * Removes all unimportant intersections from the map. Such intersections 
     * include traffic signs, road bumps, etc. The only thing that remains after
     * clearing the map, the only intersections that remain are street corners 
     * connecting multiple streets.
     * It also removes dead-end streets and intersections which cannot be returned 
     * from.
     * It does this by running iterations of clearMapIteration until the iteration
     * no longer removes additional nodes.
     * 
     * modifies {@code intersections }
     */
    public void clearMap() {
        int previousNumberNodes = intersections.size();
        // number of intersections.size() can never be negative, therefore it 
        // always runs at least once.
        int newNumberNodes = -2; 
        while (previousNumberNodes != newNumberNodes) {
            clearMapIteration();
            previousNumberNodes = newNumberNodes;
            newNumberNodes = intersections.size();
        }
    }
    
    /**
     *  Sets the idCounter to the maximum id in intersections and adds 1
     * 
     * @modifes { @code idCounter }
     */
    private void setIdCounter() {
        long idCounter = -1L;
        for (long id : intersections.keySet()) {
            if (idCounter <= id) {
                idCounter = id;
            }
        }
        idCounter++;
    }
    
    /**
     * A single iteration in the process of grouping all the intersections
     * together. 
     * In a single iteration every pair of connected intersections is checked
     * and if the distance between the intersections is smaller than the input 
     * distance, then the two intersections are grouped together. This means
     * that a single new intersection is added with incoming and outgoing roads
     * identical to the combination of the two original nodes.
     * 
     * @param distance the minimum distance such that two nodes are grouped together
     * modifies {@code intersections }
     */
    public void groupNodesIteration(double distance) {
        for (long id : intersections.keySet()) {
            Intersection interFrom = intersections.get(id);
            // check if the distance between two connected nodes is smaller than 
            // the minimum distance
            boolean check = false;
            for (Road road : interFrom.getRoadsFrom()) {
                if (distance(road.from, road.to) <= distance) {
                    check = true;
                    Intersection interTo = road.to;
                    double newLongtitude = (interFrom.longitude + interTo.longitude)/2;
                    double newLatitude = (interFrom.latitude + interTo.latitude)/2;
                    // it is very important that the id of newInter is unique!
                    Intersection newInter = new Intersection(newLongtitude, newLatitude, idCounter++);
                    for (Road inter1From : interFrom.getRoadsFrom()) {
                        if (inter1From.to.id != interTo.id) {
                            newInter.addEdge(inter1From.to, distance(newInter, inter1From.to), inter1From.speed);
                        }                     
                    }
                    for (Road inter1To : interFrom.getRoadsTo()) {
                        inter1To.from.addEdge(newInter, distance(newInter, inter1To.from), inter1To.speed);
                    }
                    for (Road inter2From : interTo.getRoadsFrom()) {
                        newInter.addEdge(inter2From.to, distance(newInter, inter2From.to), inter2From.speed);
                    }
                    for (Road inter2To : interTo.getRoadsTo()) {
                        if (inter2To.from.id != interFrom.id) {
                            inter2To.from.addEdge(newInter, distance(newInter, inter2To.from), inter2To.speed);
                        }
                    }
                    interFrom.severNode();
                    interTo.severNode(); 
                    intersections.remove(interFrom.id);
                    intersections.remove(interTo.id); 
                    intersections.put(newInter.id, newInter);
                    return;
                }
            }
        }
    }
    
    /**
     * Groups intersections together which lie close together. "close together"
     * is defined by the minimumDisatnce variable.
     * Grouping together entails that intersections whose distance from each other
     * is less than minimumDistance, are replaced by a single intersection whose 
     * incoming and outgoing nodes are the same as the combination of the grouped 
     * nodes.
     * This is accomplished by running groupNodesIteration until no additional 
     * intersections are grouped together
     * 
     * modifies {@code itnersections }
     */
    public void groupNodes() {
        int previousNumberNodes = intersections.size();
        // number of intersections.size() can never be negative, therefore it 
        // always runs at least once.
        int newNumberNodes = -2; 
        while (previousNumberNodes != newNumberNodes) {
            groupNodesIteration(minimumDistance);
            previousNumberNodes = newNumberNodes;
            newNumberNodes = intersections.size();
        }
    }
    
    /**
     * Combines grouping and clearing of nodes until the map can not
     * be simplified any further. 
     * Accomplished by clearing and grouping until no additional intersections
     * are removed
     */
    public void clearAndGroup() {
        int previousNumberNodes = intersections.size();
        // number of intersections.size() can never be negative, therefore it 
        // always runs at least once.
        int newNumberNodes = -2; 
        while (previousNumberNodes != newNumberNodes) {
            clearMap();
            groupNodes();
            previousNumberNodes = newNumberNodes;
            newNumberNodes = intersections.size();
            //System.out.println(newNumberNodes);
        }
    }
    // Still need to update index, ids and distances of nodes!!!!!!!
    
    /**
     * returns the minimum distance out of all pairs of intersections
     * @return the minimum distance of all pairs of intersections
     */
    private double minDistance() {
        double minDistance = 9999999999D;
        for (long id1 : intersections.keySet()) {
            for (long id2 : intersections.keySet()) {
                double distance = distance(intersections.get(id1), intersections.get(id2));
                if (id1 != id2 && minDistance > distance ) {
                    minDistance = distance;
                }
            }
        }
        return minDistance;
    }
    
    /**
     * Computes the minimum longitude of all intersections.
     * 
     * @return the minimum longitude of all intersections
     */
    private double minLongitude() {
        double minLong = 99999999999D;
        for (long id : intersections.keySet()) {
            if (intersections.get(id).longitude < minLong) {
                minLong = intersections.get(id).longitude;
            }
        }
        return minLong;
    }
    
    /**
     * Computes the maximum longitude of all intersections
     * 
     * @return the maximum longitude of all intersections
     */
    private double maxLongitude() {
        double maxLong = -99999999999D;
        for (long id : intersections.keySet()) {
            if (intersections.get(id).longitude > maxLong) {
                maxLong = intersections.get(id).longitude;
            }
        }
        return maxLong;
    }
    
    /**
     * Computes the minimum latitude of all intersections
     * @return the minimum latitude of all intersections
     */
    private double minLatitude() {
        double minLat = 99999999999D;
        for (long id : intersections.keySet()) {
            if (intersections.get(id).latitude < minLat) {
                minLat = intersections.get(id).latitude;
            }
        }
        return minLat;
    }
    
    /**
     * Computes the maximum latitude of all intersections
     * @return the maximum latitude of all intersections
     */
    private double maxLatitude() {
        double maxLat = -99999999999D;
        for (long id : intersections.keySet()) {
            if (intersections.get(id).latitude > maxLat) {
                maxLat = intersections.get(id).latitude;
            }
        }
        return maxLat;
    }
    
    /**
     * Computes the width of the bounding box around all the intersections.
     * @return the width of the bounding box
     */
    private double widthBoundingBox() {
        return maxLongitude() - minLongitude();
    }
    
    /**
     * Computes the height of the bounding box around all the intersections.
     * @return the height of the bounding box
     */
    public double heightBoundingBox() {
        return maxLatitude() - minLatitude();
    }
    
    /**
     * Computes the side length of a square in the grid such that every node can is
     * located in at most one square.
     * @return { @code minDistance()/1.42 }
     */
    private double minimumLengthSquare() {
        // 1.42 is an approximation of sqrt(2)
        return minDistance()/1.42;
    }
    
    /**
     * Computes the minimum grid (square) side length such that all the intersections
     * are contained within the grid.
     * 
     * @return { @code max(widthBoundingBox(), heightBoundingBox()) }
     */
    private double lengthGrid() {
        double widthBB = widthBoundingBox();
        double heightBB = heightBoundingBox();
        return ((widthBB > heightBB) ? widthBB : heightBB);
    }
    
    /**
     * Computes the number times a grid with length {@code gridLength} has to be
     * divided along both the width and length such that there is at most one intersection
     * in each square.
     * 
     * @param gridLength the length of the grid
     * @return the number of divisions to assure at most one intersection is
     *          located in each square
     */
    private long minimumDivisions(double gridLength) {
        // + 5 just to be sure
        return (long)(gridLength / minimumLengthSquare()) + 5;
    }
    
    /**
     * Computes the length of each square in a grid of length { @code mapWidth }.
     * The length of the square is computed such that at most intersection is located
     * in each square.
     * 
     * @param gridLength The length of the grid
     * @return the length of each square in a grid of length { @code mapWidth }
     */
    private double lengthSquare(double gridLength) {
        return gridLength/minimumDivisions(gridLength);
    }
    
    /**
     * A binary search algorithm to find the index of the biggest longitude/latitude 
     * that is smaller than a given longitude/latitude in a sorted list of 
     * longitudes/latitudes, or 0 if the given longitude is smaller than 
     * all the longitudes in the list. (note that 0 is the index of the first element
     * and therefore 0 either be a "correct" result or the boundary case. This was
     * don intentionally.)
     * This algorithm is used for creating the grid.
     * Note: lists must be sorted in ascending order.
     * 
     * @param list The sorted list of longitudes/latitudes
     * @param num The longitude/latitude that we want to find the index for
     * 
     * @return The index of the max longitude/latitude that is smaller than the
     *          given longitude/latitude
     */
    private int binarySearchIndex(List<Double> list, double num) {
        int L = 0; // left most index
        int R = list.size() - 1; // rightmost index;
        // boundary case: num is bigger than the biggest element in the list
        if (num >= list.get(list.size() - 1)) {
            return list.size() - 1;
        }
        // boundary case: num is smaller than the smallest element in the list
        if (num <= list.get(0)) {
            return 0;
        }
        while (L < R - 1) {
            int m = (L + R)/2;
            if (list.get(m) <= num) {
                L = m;
            } else {
                R = m;
            }
        }
        return L;
    }
    
    /**
     * Determines if a number is inside a range.
     * 
     * @param num the number to check for
     * @param leftBound the left bound of the range
     * @param rightBound the right bound of the range
     * @return { @code leftBound <= num && num <= rightBound }
     */
    private boolean inside(double num, double leftBound, double rightBound) {
        return (leftBound <= num && num <= rightBound);
    }
    
    /**
     * Create a grid used for determining the nearest intersection to any point 
     * within that grid. The grid is a square area in which the all the intersections
     * lie.
     * The grid is defined by the bottom left point, the length of the side of the grid,
     * the number of times length and the width of the grid is divided to create the 
     * squares and the length of the sides of the squares. (Note that this last
     * length can be computed from the other variables)
     * 
     * The grid is stored as a list of lists of integers. The effectively creates
     * a matrix in which each element represents a square area. Each integer in the list
     * of lists the id of the intersection that is closest to the center of the square.
     * 
     * (Based on the Manhattan distance. This is done for efficiency reasons.
     * 
     * @param inputLengthGrid The length of the grid
     * @param inputBottomLeftX The x-coordinate of the bottomLeft point
     * @param inputBottomLeftY The y-coordinate of the bottomLeft point
     * modifies { @code grid, width, bottomLeftX, bottomLeftY, squareWidth }
     */
    public void createGrid(double inputLengthGrid, double inputBottomLeftX, double inputBottomLeftY) {
        // set the parameters defining the grid
        gridLength = inputLengthGrid;
        bottomLeftX = inputBottomLeftX;
        bottomLeftY = inputBottomLeftY;
        squareLength = lengthSquare(inputLengthGrid);
        
        // Create the veronoi diagram
        List<PointD> points = new ArrayList<>();
        // map from x to map from y to intersection id
        Map<Double, Map<Double, Long>> pointToId = new HashMap<>();
        for (long id : intersections.keySet()) {
            PointD point = new PointD(intersections.get(id).longitude, intersections.get(id).latitude);
            points.add(point);
            if (pointToId.containsKey(intersections.get(id).longitude)) {
                pointToId.get(intersections.get(id).longitude).put(intersections.get(id).latitude, id);
            } else {
                Map<Double, Long> yToId = new HashMap<>();
                yToId.put(intersections.get(id).latitude, id);
                pointToId.put(intersections.get(id).longitude, yToId);
            }
            
        }
        PointD[] pointsArray = points.toArray(new PointD[points.size()]);
        RectD boundingBox = new RectD(bottomLeftX, bottomLeftY, bottomLeftX + gridLength, bottomLeftY + gridLength);
        
        VoronoiResults voronoiResult = Voronoi.findAll(pointsArray, boundingBox);
        VoronoiMap voronoiMap = new VoronoiMap(voronoiResult);
        Subdivision subdivision = voronoiMap.source();
        PointD[] sites = voronoiMap.target().generatorSites;
        SubdivisionSearch subdivisionSearch = new SubdivisionSearch(subdivision, false);
        subdivisionSearch.validate();
        
        long numberDivisions = minimumDivisions(gridLength);
        // start creating the grid
        grid = new ArrayList<>();
        for (int x = 0; x < numberDivisions; x++) {
            // ignore this bottom comment. Part of the old implementation
            //grid.add(new ArrayList<>());
            double centerX = (x + 0.5) * squareLength + bottomLeftX;
            
            // implementattion with O(log(numberDivisions)) running time, based on binary search
            List<Long> column = new ArrayList<>(Collections.nCopies((int)numberDivisions, (long)-1));
            grid.add(column);
            boolean findingFirstId = true;
            boolean done = false;
            int currentIndex = 0;
            int firstIndex = 0;
            Long currentId;
            Long idToBeFound = -1L;
            int rightIndexBound = (int)numberDivisions - 1;
            int leftIndexBound = 0;
            while (!done) {
                // if Id already found, simply add it
                if (grid.get(x).get(currentIndex) < 0) {
                    double centerY = (currentIndex + 0.5) * squareLength + bottomLeftY;
                    PointD point = new PointD(centerX, centerY);
                    SubdivisionElement element = subdivisionSearch.find(point);
                    SubdivisionFace face;
                    if (element.type == SubdivisionElementType.FACE) {
                        face = element.face();
                    } else if (element.type == SubdivisionElementType.EDGE) {
                        SubdivisionEdge edge = element.edge();
                        face = edge.face();  
                    } else {
                        PointD vertex = element.vertex();
                        face = subdivision.findFace(point);
                    }
                    int siteIndex = voronoiMap.fromFace(face);
                    PointD site = sites[siteIndex];
                    long id = pointToId.get(site.x).get(site.y);
                    grid.get(x).set(currentIndex, id);
                }
                currentId = grid.get(x).get(currentIndex);
                if (findingFirstId) {
                    idToBeFound = currentId;
                    firstIndex = currentIndex;
                    currentIndex = (currentIndex + rightIndexBound)/2;
                    findingFirstId = false;
                } else {
                    if (leftIndexBound + 1 == rightIndexBound) {
                        for (int i = firstIndex; i <= leftIndexBound; i++) {
                            grid.get(x).set(i, idToBeFound);
                        }
                        if (rightIndexBound == numberDivisions - 1) {
                            grid.get(x).set(rightIndexBound, idToBeFound);
                            done = true;
                        }
                        currentIndex = rightIndexBound;
                        rightIndexBound = (int)numberDivisions - 1;
                        leftIndexBound = currentIndex;
                        findingFirstId = true;
                    } else {
                        if (Objects.equals(currentId, idToBeFound)) {
                            leftIndexBound = currentIndex;
                            currentIndex = Math.max(currentIndex + 1, (leftIndexBound + rightIndexBound)/2);
                        } else {
                            rightIndexBound = currentIndex;
                            currentIndex = Math.min(currentIndex - 1, (leftIndexBound + rightIndexBound)/2);
                        }
                    }
                }
            }
            
            // old implementation with O(numberDivisions) running time
            /*
            for (int y = 0; y < numberDivisions; y++) {
                counter++;
                double centerY = (y + 0.5) * squareLength + bottomLeftY;
                // for each square, find the closest interesction to the center of the 
                // square
                PointD point = new PointD(centerX, centerY);
                SubdivisionElement element = subdivisionSearch.find(point);
                SubdivisionFace face;
                if (element.type==SubdivisionElementType.FACE) {
                    face = element.face();
                } else if (element.type==SubdivisionElementType.EDGE) {
                    SubdivisionEdge edge = element.edge();
                    face = edge.face();  
                } else {
                    PointD vertex = element.vertex();
                    face = subdivision.findFace(point);
                }
                int siteIndex = voronoiMap.fromFace(face);
                PointD site = sites[siteIndex];
                long id = pointToId.get(site.x).get(site.y);
                grid.get(x).add(id);

            }
            */
            assert(grid.get(x).size() == numberDivisions);
        }
        assert(grid.size() == numberDivisions);
    }
    
    /**
     * Creates the grid with using the bounding box of the map.
     * 
     */
    public void createGrid() {
        createGrid(lengthGrid(), minLongitude(), minLatitude());
    }
    
    /**
     * Uses the grid to find the nearest intersection of a point defined by the 
     * { @code longitude, latitude }.
     * The intersection is returned as an id.
     * If the grid isn't created yet when this method is called, it is created first
     * 
     * @param longitude The longitude of the point
     * @param latitude The latitude of the point
     * @return The closest intersection to a specific point
     */
    private long getIntersection(double longitude, double latitude) {
        // check if the grid has already been created. If not create one.
        if (grid == null) {
            createGrid();
        }
        // find the correct square based on the coordinates of the point
        int x = (int)((longitude - bottomLeftX)/squareLength);
        int y = (int)((latitude - bottomLeftY)/squareLength);
        return grid.get(x).get(y);
    }
    
    /**
     * Outputs the created map as a JSON file.
     * The JSON file first defines the number of intersections in "numberIntersections"
     * and the minimum and the maximum longitude and the latitude. 
     * This defines a bounding box around the map.
     * Then it provides an array of intersections in "intersections".
     * Each intersection has an id, longitude, latitude and an array of
     * outgoing roads.
     * Each road in turn has the id of the intersection the road goes to, 
     * a speed limit and a distance (length of the road).
     * This JSON file is save as [filename]map.json
     * e.g. SanFrancisco_map.json
     * And it is saved in the /maps/ directory.
     * 
     * In the output the ids of the intersection are also changed according
     * to the map oldToNewId. This is implemented such that the the very big ids
     * in OpenStreetMaps are reduced to smaller ids. Standard, the new ids
     * range from 0 to n with n being the number of intersections in the map.
     * 
     * @param oldToNewId The mapping from old to new ids.
     */
    public void outputMap(Map<Long, Long> oldToNewId) {
        JSONObject map = new JSONObject();
        map.put("numberIntersections", intersections.size());
        map.put("maximumLatitude", maxLatitude());
        map.put("minimumLatitude", minLatitude());
        map.put("maximumLongitude", maxLongitude());
        map.put("minimumLongitude", minLongitude());
        JSONArray intersectionsJSON = new JSONArray();
        for (long id : intersections.keySet()) {
            JSONObject intersectionJSON = new JSONObject();
            // set the data of the intersection
            intersectionJSON.put("id", oldToNewId.get(id));
            intersectionJSON.put("longitude", intersections.get(id).longitude);
            intersectionJSON.put("latitude", intersections.get(id).latitude);
            JSONArray roads = new JSONArray();
            // set the outgoing roads from the current intersection 
            for (Road roadFrom : intersections.get(id).getRoadsFrom()) {
                JSONObject road = new JSONObject();
                road.put("to", oldToNewId.get(roadFrom.to.id));
                road.put("speed", roadFrom.speed);
                road.put("distance", roadFrom.distance);
                roads.add(road);
            }
            intersectionJSON.put("roads", roads);
            intersectionsJSON.add(intersectionJSON);
        }
        map.put("intersections", intersectionsJSON);
        
        // write the JSON object to a file
        try (FileWriter file = new FileWriter("maps/"+ filename + "_map.json")) {

            file.write(map.toJSONString());
            file.flush();

        } catch (IOException e) {
            e.printStackTrace();
        }
        
    }
    
    /**
     * Outputs the map with the standard map from old to new ids.
     */
    public void outputMap() {
        // generate mapping
        Map<Long, Long> oldToNewIds = oldToNewIds();
        outputMap(oldToNewIds);
    }
    
    /** 
     * Outputs the grid as a JSON file.
     *  The JSON file first contains the parameters defining the grid, namely
     * the bottom left point (x- and y-coordinates), the length of the sides
     * of the grid and the number of divisions along the length and the width of the
     * grid.
     * Then the file contains a matrix of intersection ids, mapping the squares to
     * the nearest intersection.
     * If the grid has not yet been created upon calling outputGrid, the grid 
     * is first created.
     * 
     * This JSON file is save as [filename]_grid.json
     * e.g. SanFrancisco_grid.json
     * And it is saved in the /maps/ directory.
     * 
     * In the output the ids of the intersection are also changed according
     * to the map oldToNewId. This is implemented such that the the very big ids
     * in OpenStreetMaps are reduced to smaller ids. Standard, the new ids
     * range from 0 to n with n being the number of intersections in the map.
     * (You do have to ensure that the oldToNewIds map is identical to the 
     * one used in outputMap(...). If the map and the grid are output together 
     * using the outputMapAndGrid() method, then this is ensured automatically.)
     * 
     * @param oldToNewIds The mapping from old to new ids.
     */
    public void outputGrid(Map<Long, Long> oldToNewIds) {
        // if the grid has not been crated yet, create it
        if (grid == null) {
            createGrid();
        }
        JSONObject gridObj = new JSONObject();
        // set the parametrs of the grid
        gridObj.put("bottomLeftX", bottomLeftX);
        gridObj.put("bottomLeftY", bottomLeftY);
        gridObj.put("gridLength", gridLength);
        gridObj.put("numberDivisions", grid.size());
        JSONArray columns = new JSONArray();
        // create the grid
        for (List<Long> column : grid) {
            JSONArray ids = new JSONArray();
            for (long id : column) {
                ids.add(oldToNewIds.get(id));
            }
            columns.add(ids);
        }
        gridObj.put("grid", columns);
        
        // output the grid to file
        try (FileWriter file = new FileWriter("maps/"+ filename + "_grid.json")) {
            
            gridObj.writeJSONString(file);
            //file.write(gridObj.toJSONString());
            file.flush();

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    
     /**
     * Outputs the map with the standard map from old to new ids.
     */
    public void outputGrid() {
        // generate mapping
        Map<Long, Long> oldToNewIds = oldToNewIds();
        outputGrid(oldToNewIds);
    }
    
    /**
     * Outputs the map and the grid with the standard mapping from old
     * to new ids.
     */
    public void outputMapAndGrid() {
        // generate mapping
        Map<Long, Long> oldToNewIds = oldToNewIds();
        outputMap(oldToNewIds);
        outputGrid(oldToNewIds);
    }
    
    /**
     * Maps the old ids of the intersections to a new set of ids ranging from 
     * 0 to n with n being the number of intersections in the map. This is 
     * done to reduce the length of the ids compared the the ids used in OpenStreetMaps.
     * 
     * @return The mapping from the old to new ids. 
     */
    private Map<Long, Long> oldToNewIds() {
        // in the output, the ids of the intersections are changed to new ids 
        // starting at 0.
        Map<Long, Long> oldToNewId = new HashMap<>(); // map from old id to new id
        long index = 0;
        // assign the old ids to new ids from 0 to n with n being the number of
        // intersections in the map
        for (long id : intersections.keySet()) {
            oldToNewId.put(id, index++);
        }
        return oldToNewId;
    }
}
