import javax.swing.*;
import java.awt.*;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.Random;
import java.util.Map;
import java.util.HashMap;

/**
 * @author Robert van Barlingen
 * mail Bobbhy.van.Barlingen@gmail.com
 * 
 * The mapVisualizer visualizes the map generated by the MapCreator. It can visualize
 * both the city map as a graph of nodes and the grid as a voronoi diagram. The voronoi
 * diagram creates areas indicated by a different colors. Every point within such
 * a colored area are mapped to the same intersection.
 * 
 * The visualizer takes a CityMap as input. Certain aspects of the visualization 
 * such as the border, the screen height and width and the diameter of the nodes
 * can be set.
 * 
 * Generating these visualizations take a lot of time to generate. Therefore they 
 * should be used as a tool to check the map, not as a simulation tool for visualizing taxis. 
 */
public class MapVisualizer extends JFrame  {
    // the map 
    private CityMap cityMap;
    
    private int windowWidth = 1500;
    private int windowHeight = 1000;
    private int circleDiameter = 8; // the diameter of the circles representing the nodes
    private int lengthArrow = 8; // the length of legs of the arrows
    private int border = 100; // the width of the border between the map and the window edges
    // indicates whether to show the arrows on the roads indicating the direction
    private boolean showArrows = true; 
    // indicates whether to show the voronoi diagram behind the map
    // The vonoroi diagram show all the areas that are mapped to the same intersection
    // based on approximity
    private boolean showGrid = true;
    
    // a mapping from the id of every intersection to a different color. this
    // is used to construct the voronoi diagram representing the grid
    private Map<Long, Color> interColors;
    
    /**
     * The constructor of the class. Sets the city map, sets the frame and
     * { @code showArrows, showGrid }.
     * 
     * @param cityMap The city map that is used for the visualization
     * @param showGrid Whether to show the grid
     * @param showArrows Whether to show the arrows on the roads.
     * modifies { @code cityMap }
     */
    public MapVisualizer(CityMap cityMap, boolean showGrid, boolean showArrows) {
        this.cityMap = cityMap;
        setFrame();
        this.showGrid = showGrid;
        this.showArrows = showArrows;
    }
    
    /**
     * The constructor of the class. Sets the city map and sets the frame.
     * @param cityMap 
     */
    public MapVisualizer(CityMap cityMap) {
        this.cityMap = cityMap;
        setFrame();
    }
    
    /**
     * Sets the dimensions of the window to the specified width and height
     * 
     * @param width Width of the window (in pixels)
     * @param height Height of the window (in pixels)
     */
    public void setWindowDimensions(int width, int height) {
        windowWidth = width;
        windowHeight = height;
    }
    
    /**
     * Sets the border around the map in the screen to { @code inputBorder }
     * 
     * @param inputBorder the value to set the border to
     */
    public void setBorder(int inputBorder) {
        border = inputBorder;
    }
    
    /**
     * Sets length of the arrows on the roads { @code this.lengthArrow }
     * 
     * @param lengthArrow the length of the Arrow
     */
    public void setLengthArrow(int lengthArrow) {
        this.lengthArrow = lengthArrow;
    }
    
    /**
     * Sets the diameter of the circles representing the intersections
     * to { @code diameter }
     * 
     * @param diameter The value to set the diameter of the circles to 
     */
    public void setCircleDiameter(int diameter) {
        circleDiameter = diameter;
    }
    
    /**
     * Sets { @code showArrows } which determines whether there are arrows
     * on the roads indicating the direction of the roads
     * 
     * @param bool the boolean variable which showArrows is set to 
     */
    public void setShowArrows(boolean bool) {
        showArrows = bool;
    }
    
    /**
     * Sets { @code showGrid } which determines whether the voronoi diagram 
     * is shown behind the map.
     * 
     * @param bool the boolean variable which showGrid is set to 
     */
    public void setShowgrid(boolean bool) {
        showGrid = bool;
    }
    
    /**
     * Sets up the frame.
     */
    public final void setFrame() {
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setTitle("Map");
        this.setSize(windowWidth, windowHeight);
        this.setLocationRelativeTo(null);
        this.setVisible(true);
        this.setResizable(false);
    }
    
        // takes a map coordinate and returns the corresponding screen coordinate

    /**
     * Takes the longitude of a point on the map and converts it to the corresponding 
     * x-coordinate on the screen.
     * 
     * @param longitude The longitude of the point on the map to be converted
     * @return The corresponding x-coordinate (pixel) in the window
     */
    public int mapToWindowX(double longitude) {
        return border + (int)(((longitude - cityMap.minLongitude())/(cityMap.maxLongitude() - cityMap.minLongitude())) * (windowWidth - 2 * border));
    }
    
    /**
     * Takes the latitude of a point on the map and converts it to the corresponding
     * y-coordinate on the screen
     * 
     * @param latitude The latitude of the point on the map to be converted 
     * @return The corresponding y-coordinate (pixel) in the window
     */
    public int mapToWindowY(double latitude) {
        return border + (int)(((cityMap.maxLatitude() - latitude)/(cityMap.maxLatitude() - cityMap.minLatitude())) * (windowHeight - 2 * border));
    }
    
    /**
     * converts the side length of the squares in the grid from the map space to 
     * the width of the corresponding rectangle on the screen.
     * For example, a square area with a side length of 50 kilometers could be 
     * converted to a width of 3 pixels in the window.
     * Notice that this width must be at least 1 pixel.
     * 
     * @return the width of the a rectangle in the window corresponding to a square
     *          in the grid.
     */
    public int squareLengthToScreenWidth() {
        return Math.max(1, (int)(cityMap.squaresSideLength()*(windowWidth - 2 * border)/(cityMap.bottomLeftX() + cityMap.gridSideLength())));
    }
    
    /**
     * converts the side length of the squares in the grid from the map space to 
     * the height of the corresponding rectangle on the screen.
     * For example, a square area with a side length of 50 kilometers could be 
     * converted to a height of 3 pixels in the window.
     * Notice that this height must be at least 1 pixel.
     * 
     * @return the height of the a rectangle in the window corresponding to a square
     *          in the grid.
     */
    public int squareLengthToScreenHeight() {
        return Math.max(1, (int)(cityMap.squaresSideLength()*(windowHeight - 2 * border)/(cityMap.bottomLeftY() + cityMap.gridSideLength())));
    }
    
    /**
     * converts the x-coordinate a point in the window to the corresponding 
     * longitude in the map
     * 
     * @param x The x-coordinate of the point the window
     * @return the corresponding longitude on the map
     */
    public double windowToMapX(int x) {
        return (double)(((x - border)*(cityMap.maxLongitude() - cityMap.minLongitude()))/((double)(windowWidth - 2 * border)) + cityMap.minLongitude());
        //return ((double)(x - border)/(double)(windowWidth - 2 * border)) * cityMap.maxLongitude();
    }
    
    /**
     *
     * converts the y-coordinate a point in the window to the corresponding 
     * latitude in the map
     * 
     * @param y The y-coordinate of the point the window
     * @return the corresponding latitude on the map
     */
    public double windowToMapY(int y) {
        return (double)(((-y + border)*(cityMap.maxLatitude() - cityMap.minLatitude()))/((double)(windowHeight - 2 * border)) + cityMap.maxLatitude());
    }

    /**
     * Generates for each intersection a different color which is used to construct
     * the voronoi diagram. 
     * These colors are saves as a map from the intersection id to the corresponding
     * color. 
     */
    public void setColors() {
        interColors = new HashMap<>();
        Random rng = new Random();
        for (Intersection inter : cityMap) {
            interColors.put(inter.id, new Color(rng.nextInt(256), rng.nextInt(256), rng.nextInt(256)));
        }
    }
    
    /**
     * Draws the visualizations in the window.
     * Standard is draws the voronoi diagram, which represents the grid in the 
     * background, and draws the map which is represented by a graph of nodes
     * and edges in the foreground. 
     * Certain modifications can be made. For example, the voronoi diagram
     * can be turned off and the drawing of the arrows on the roads can also
     * be turned off.
     * 
     * @param g Class used to draw. 
     */
    @Override
    public void paint(Graphics g) {
        // If cityMap has a grid and the showGrid boolean is true, the
        // it draws the grid.
        if (cityMap.hasGrid() && showGrid ) {
            try {
                setColors();
                drawGrid(g);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
        
        g.setColor(Color.black);
        for (Intersection inter : cityMap) {
            drawIntersection(g, inter);
            for(Road road : inter.getRoadsFrom()) {
                drawRoad(g, road);
            }
        }
    }
    

    
    /**
     *
     * @param g Instance of Graphics used to draw
     * @throws java.io.FileNotFoundException if { @code cityMap } doesn't have a grid
     */
    public void drawGrid (Graphics g) throws FileNotFoundException {
        // Loop over each pixel in the window
        for (int x = border; x <= windowWidth - border; x++) {
            for (int y = border; y <= windowHeight - border; y++) {
                // first check if the pixel is even in the grid
                if (cityMap.inGrid(windowToMapX(x), windowToMapY(y))) {
                    // if so, then color the pixel in the color of the intersection
                    g.setColor(interColors.get(cityMap.getNearestIntersection(windowToMapX(x), windowToMapY(y)).id));
                    g.drawLine(x, y, x, y);
                }
            }
        }
    } 
    
    /**
     * Draws a single intersection as a circle in the window
     * 
     * @param g The class used to draw the intersection
     * @param inter The intersection that is drawn
     */
    public void drawIntersection (Graphics g, Intersection inter) {
        int x = mapToWindowX(inter.longitude);
        int y = mapToWindowY(inter.latitude);
        g.drawOval(x - circleDiameter/2, y - circleDiameter/2, circleDiameter, circleDiameter);
    }
    
    /**
     * Draws a single road as a line connecting two intersections
     * 
     * @param g the class used to draw the roads
     * @param road The road to be drawn
     */
    public void drawRoad (Graphics g, Road road) {
        Intersection inter1 = road.to;
        Intersection inter2 = road.from;
        // draw line
        int x1 = mapToWindowX(inter1.longitude);
        int y1 = mapToWindowY(inter1.latitude);
        int x2 = mapToWindowX(inter2.longitude);
        int y2 = mapToWindowY(inter2.latitude);
        g.drawLine(x1, y1, x2, y2);
        
        //draw arrow
        double t = ((double)circleDiameter)/Math.sqrt((double)((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)));
        int baseX = x1 + (int)(t*(double)(x2-x1));
        int baseY = y1 + (int)(t*(double)(y2-y1));
        double length = (2.0/1.41)*(double) lengthArrow;
        double temp1 = length/Math.sqrt((double)((x2-baseX) * (x2-baseX) + (y2-baseY) * (y2-baseY)));
        //double temp2 = length/Math.sqrt((double) ((-y2-baseX) * (-y2-baseY) + (x2-baseY) * (x2-baseY)));
        double temp1X = temp1*(double)(x2-baseX);
        double temp1Y = temp1*(double)(y2-baseY);
        double point1X = baseX + temp1X;
        double point1Y = baseY + temp1Y;
        double point2X = baseX + (temp2*(double)(-y2-baseX));
        double point2Y = baseY + (temp2*(double)(x2-baseY));
        double point3X = baseX + (-temp2*(double)(-y2-baseX));
        double point3Y = baseY + (-temp2*(double)(x2-baseY));
        int final1X = (int)(point1X + point2X/2.0);
        int final1Y = (int)(point1Y + point2Y/2.0);
        int final2X = (int)(point1X + point3X/2.0);
        int final2Y = (int)(point1Y + point3Y/2.0);
        //g.drawLine(final1X, final1Y, baseX, baseY);
        //g.drawLine(final2X, final2Y, baseX, baseY);
        g.fillOval((int)baseX, (int)baseY, 4, 4);
        
        
        
        
    }
}
